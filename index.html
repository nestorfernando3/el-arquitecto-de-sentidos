<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Archivist</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
            color: #dcdcdc;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        #header {
            text-align: left;
            opacity: 0.7;
        }

        h1 {
            font-size: 1.2rem;
            margin: 0;
            letter-spacing: 2px;
            text-transform: uppercase;
            border-bottom: 1px solid #555;
            display: inline-block;
            padding-bottom: 5px;
        }

        #status {
            font-size: 0.9rem;
            margin-top: 5px;
            color: #888;
        }

        #narrative-box {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid #333;
            padding: 20px;
            text-align: center;
            font-size: 1.1rem;
            line-height: 1.5;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            display: none;
            /* Controlled by JS */
            transition: opacity 0.5s;
        }

        .highlight {
            color: #ffaa00;
            font-weight: bold;
        }

        /* Intro Screen */
        #intro-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s;
        }

        #intro-text {
            max-width: 600px;
            text-align: center;
            margin-bottom: 40px;
        }

        .typewriter p {
            overflow: hidden;
            white-space: nowrap;
            margin: 0 auto;
            letter-spacing: .15em;
            animation: typing 3.5s steps(40, end);
            border-right: .15em solid orange;
        }

        button {
            background: transparent;
            border: 1px solid #666;
            color: #ccc;
            padding: 15px 30px;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
        }

        button:hover {
            border-color: #fff;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        /* Vignette */
        #vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle, transparent 40%, rgba(0, 0, 0, 0.8) 100%);
            z-index: 10;
        }
    </style>
</head>

<body>

    <div id="intro-screen">
        <div id="intro-text">
            <p>ARCHIVE TERMINAL [SESSION 1]</p>
            <br>
            <p>REALITY FRAGMENTATION DETECTED.</p>
            <p>MEANING INTEGRITY: CRITICAL.</p>
            <br>
            <p>INITIATE RESTORATION PROTOCOL?</p>
        </div>
        <button id="start-btn">ACCESS DESK</button>
    </div>

    <div id="vignette"></div>

    <div id="ui-layer">
        <div id="header">
            <h1>The Archivist</h1>
            <div id="status">CASE #001: THE TREE</div>
        </div>
        <div id="narrative-box"></div>
    </div>

    <div id="canvas-container"></div>

    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        class Game {
            constructor() {
                this.container = document.getElementById('canvas-container');

                // Scene Setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a0a); // Very dark grey
                this.scene.fog = new THREE.Fog(0x0a0a0a, 10, 20);

                // Camera (Fixed Top-Down/Angled)
                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
                this.camera.position.set(0, 12, 5);
                this.camera.lookAt(0, 0, 0);

                this.initRenderer();
                this.initLights();
                this.initPostProcessing();
                this.initInput();

                // Game State
                this.objects = []; // Interactables
                this.draggedObject = null;
                this.plane = new THREE.Plane(); // Intersection plane for dragging
                this.pIntersect = new THREE.Vector3();
                this.mouseOffset = new THREE.Vector3();

                this.levelState = 'intro'; // intro, playing, complete

                // Start Loop
                window.addEventListener('resize', () => this.onWindowResize());
                this.animate();

                // UI Hooks
                document.getElementById('start-btn').addEventListener('click', () => this.startGame());
            }

            initRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                this.container.appendChild(this.renderer.domElement);
            }

            initLights() {
                // Desk Lamp Effect (Spotlight)
                this.spotLight = new THREE.SpotLight(0xffeeb1, 10); // Warm light
                this.spotLight.position.set(2, 10, 2);
                this.spotLight.angle = Math.PI / 6;
                this.spotLight.penumbra = 0.5;
                this.spotLight.decay = 1.5;
                this.spotLight.distance = 50;
                this.spotLight.castShadow = true;
                this.spotLight.shadow.mapSize.width = 1024;
                this.spotLight.shadow.mapSize.height = 1024;
                this.scene.add(this.spotLight);

                // Dim Ambient
                this.ambientLight = new THREE.AmbientLight(0x404040, 2);
                this.scene.add(this.ambientLight);
            }

            initPostProcessing() {
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera)); // Standard Render

                // Bloom (Subtle, for magic moments)
                this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                this.bloomPass.strength = 0; // Start off
                this.bloomPass.threshold = 0.5;
                this.bloomPass.radius = 0.5;
                this.composer.addPass(this.bloomPass);

                this.composer.addPass(new OutputPass());
            }

            startGame() {
                // Fade out intro
                document.getElementById('intro-screen').style.opacity = 0;
                setTimeout(() => {
                    document.getElementById('intro-screen').style.display = 'none';
                    this.buildDesk();
                }, 1000);
            }

            buildDesk() {
                // 1. The Desk Surface
                const deskGeometry = new THREE.PlaneGeometry(20, 10);
                const deskMaterial = new THREE.MeshStandardMaterial({
                    color: 0x3d2817,
                    roughness: 0.8,
                    metalness: 0.1
                });
                const desk = new THREE.Mesh(deskGeometry, deskMaterial);
                desk.rotation.x = -Math.PI / 2;
                desk.receiveShadow = true;
                this.scene.add(desk);

                this.spawnLevel1();
            }

            spawnLevel1() {
                this.showMessage("Evidence retrieved. The semantic link is broken. <br> <span class='highlight'>Reattach the Word to the Object.</span>");
                this.levelState = 'playing';

                // --- 1. The Object (Polaroid) ---
                const photoGroup = new THREE.Group();

                // Paper Base
                const cardGeo = new THREE.BoxGeometry(3, 0.05, 3.5); // Slightly thick paper
                const cardMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 });
                const photoBase = new THREE.Mesh(cardGeo, cardMat);
                photoBase.castShadow = true;
                photoBase.receiveShadow = true;
                photoGroup.add(photoBase);

                // The Image (Dark square for now, representing the tree photo)
                const imgGeo = new THREE.PlaneGeometry(2.6, 2.6);
                const imgMat = new THREE.MeshStandardMaterial({ color: 0x111111 }); // Dark placeholder
                const imgMesh = new THREE.Mesh(imgGeo, imgMat);
                imgMesh.rotation.x = -Math.PI / 2;
                imgMesh.position.y = 0.03; // slightly above paper
                imgMesh.position.z = -0.2; // Offset for polaroid style
                photoGroup.add(imgMesh);

                // Actual Low Poly Tree Model popping out of the photo (The "Magic" element)
                const treeGroup = new THREE.Group();
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.2, 0.8, 5),
                    new THREE.MeshStandardMaterial({ color: 0x3e2723 })
                );
                trunk.position.y = 0.4;
                treeGroup.add(trunk);

                const leaves = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(0.6),
                    new THREE.MeshStandardMaterial({ color: 0x2e7d32 })
                );
                leaves.position.y = 0.9;
                treeGroup.add(leaves);

                treeGroup.position.y = 0;
                treeGroup.position.z = -0.2;
                // Tree is initially Grey/Glitching? Or just there?
                // Let's make it Grey first.
                trunk.material.color.setHex(0x555555);
                leaves.material.color.setHex(0x777777);

                photoGroup.add(treeGroup);

                // Initial Position (Random)
                photoGroup.position.set(-3, 0.1, 1);
                photoGroup.rotation.y = (Math.random() - 0.5) * 0.5; // Slight messy rotation

                this.scene.add(photoGroup);
                this.makeInteractable(photoGroup, 'target');
                this.photoGroup = photoGroup; // Ref for logic
                this.treeTrunk = trunk;
                this.treeLeaves = leaves;


                // --- 2. The Word (Index Card) ---
                const textGroup = new THREE.Group();

                // Card Base
                const indexGeo = new THREE.BoxGeometry(2, 0.05, 1);
                const indexMat = new THREE.MeshStandardMaterial({ color: 0xf5f5dc }); // Beige paper
                const indexBase = new THREE.Mesh(indexGeo, indexMat);
                indexBase.castShadow = true;
                indexBase.receiveShadow = true;
                textGroup.add(indexBase);

                // Text "TREE" (Canvas Texture)
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = "#f5f5dc"; // match bg
                ctx.fillRect(0, 0, 256, 128);
                ctx.fillStyle = "#aa0000"; // Red text like a stamp
                ctx.font = "bold 60px Courier New";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("TREE", 128, 64);

                const tex = new THREE.CanvasTexture(canvas);
                const label = new THREE.Mesh(
                    new THREE.PlaneGeometry(1.8, 0.9),
                    new THREE.MeshBasicMaterial({ map: tex, transparent: true })
                );
                label.rotation.x = -Math.PI / 2;
                label.position.y = 0.03;
                textGroup.add(label);

                // Initial Position (Random)
                textGroup.position.set(3, 0.1, -1);
                textGroup.rotation.y = (Math.random() - 0.5) * 1.0;

                this.scene.add(textGroup);
                this.makeInteractable(textGroup, 'draggable');
                this.textGroup = textGroup;
            }

            makeInteractable(mesh, type) {
                mesh.userData.interactable = true;
                mesh.userData.type = type;
                // Add bounding box for easier raycasting if needed, but group works for now
                this.objects.push(mesh);
            }

            initInput() {
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('mousedown', (e) => this.onMouseDown(e));
                window.addEventListener('mouseup', () => this.onMouseUp());
            }

            onMouseMove(e) {
                this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);

                if (this.draggedObject) {
                    if (this.raycaster.ray.intersectPlane(this.plane, this.pIntersect)) {
                        this.draggedObject.position.copy(this.pIntersect.sub(this.mouseOffset));
                        // Lift slightly while dragging
                        this.draggedObject.position.y = 1.0;
                    }
                } else {
                    // Hover effects?
                    document.body.style.cursor = 'default';
                    const intersects = this.raycaster.intersectObjects(this.objects, true); // Recursive
                    if (intersects.length > 0) {
                        // Find the root group
                        let group = intersects[0].object;
                        while (group.parent && group.parent !== this.scene) {
                            group = group.parent;
                        }
                        if (group.userData.interactable) {
                            document.body.style.cursor = 'grab';
                        }
                    }
                }
            }

            onMouseDown(e) {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.objects, true);

                if (intersects.length > 0) {
                    // Find group root
                    let group = intersects[0].object;
                    while (group.parent && group.parent !== this.scene) {
                        group = group.parent;
                    }

                    if (group.userData.interactable && group.userData.type === 'draggable') {
                        this.draggedObject = group;
                        this.plane.setFromNormalAndCoplanarPoint(
                            new THREE.Vector3(0, 1, 0),
                            group.position
                        );

                        if (this.raycaster.ray.intersectPlane(this.plane, this.pIntersect)) {
                            this.mouseOffset.copy(this.pIntersect).sub(group.position);
                        }
                        document.body.style.cursor = 'grabbing';
                        return;
                    }
                }
            }

            onMouseUp() {
                if (this.draggedObject) {
                    this.draggedObject.position.y = 0.1; // Drop back to desk
                    this.checkConnection();
                    this.draggedObject = null;
                    document.body.style.cursor = 'grab';
                }
            }

            checkConnection() {
                if (this.levelState !== 'playing') return;

                // Check distance between Word (dragged) and Photo (target)
                // World position of centers
                const dist = this.textGroup.position.distanceTo(this.photoGroup.position);

                // Threshold to "Snap"
                if (dist < 2.0) {
                    this.snapAndWin();
                }
            }

            snapAndWin() {
                this.levelState = 'complete';

                // 1. Audio/Visual Snap
                // Move text onto the bottom of the photo
                // Relative to world:
                // We want the text card to basically align with the bottom of the polaroid.

                // Animate snap (simple teleport for now, lerp later if needed)
                this.textGroup.position.copy(this.photoGroup.position);
                this.textGroup.position.z += 1.5; // Below the image part
                this.textGroup.position.y = 0.15; // On top of photo base
                this.textGroup.rotation.y = this.photoGroup.rotation.y; // Align rotation
                this.textGroup.rotation.x = 0; // Flat

                // Disable interaction
                this.textGroup.userData.interactable = false;

                // 2. Magic Effect
                this.bloomPass.strength = 1.5;

                // Color the tree
                this.treeTrunk.material.color.setHex(0x5d4037);
                this.treeLeaves.material.color.setHex(0x4caf50);
                this.treeLeaves.material.emissive.setHex(0x2e7d32);
                this.treeLeaves.material.emissiveIntensity = 0.5;

                // Narrative
                this.showMessage("<span class='highlight'>CONNECTION ESTABLISHED.</span><br>The bond is arbitrary, yet it anchors the object to reality.");

                // Next Level Button?
                setTimeout(() => {
                    // Fade bloom down
                    const fade = setInterval(() => {
                        this.bloomPass.strength *= 0.95;
                        if (this.bloomPass.strength < 0.1) clearInterval(fade);
                    }, 50);

                    this.showStamp();
                }, 2000);
            }

            showStamp() {
                // TODO: Add visual 'CASE CLOSED' stamp.
                // For now, just update text.
                const status = document.getElementById('status');
                status.innerText = "CASE #001: CLOSED";
                status.style.color = "#4caf50";
            }

            showMessage(html) {
                const box = document.getElementById('narrative-box');
                box.innerHTML = html;
                box.style.display = 'block';
                // Trigger reflow
                void box.offsetWidth;
                box.style.opacity = 1;
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                // Subtle float for the tree leaves to make it feel "alive" when solved
                if (this.levelState === 'complete' && this.treeLeaves) {
                    this.treeLeaves.position.y = 0.9 + Math.sin(Date.now() * 0.002) * 0.05;
                }

                this.composer.render();
            }
        }

        window.gameInstance = new Game();
    </script>
</body>

</html>