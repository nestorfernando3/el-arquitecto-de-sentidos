<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>El Arquitecto de Sentidos</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            color: #ccc;
            user-select: none;
            cursor: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            /* Starts hidden for intro */
            transition: opacity 2s;
        }

        /* Intro / Narrative Overlay */
        #narrative-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            background: #000;
            pointer-events: auto;
            text-align: center;
        }

        .narrative-text {
            font-size: 1.5rem;
            max-width: 600px;
            line-height: 1.6;
            margin-bottom: 2rem;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 1s, transform 1s;
        }

        .narrative-text.active {
            opacity: 1;
            transform: translateY(0);
        }

        #start-btn {
            padding: 15px 30px;
            background: transparent;
            border: 1px solid #fff;
            color: #fff;
            font-family: inherit;
            font-size: 1.2rem;
            cursor: pointer;
            opacity: 0;
            transition: opacity 1s, background 0.3s, color 0.3s;
            display: none;
            /* hidden until end of intro text */
        }

        #start-btn:hover {
            background: #fff;
            color: #000;
        }

        /* Custom Reticle */
        #reticle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            border: 1px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            mix-blend-mode: difference;
            transition: all 0.2s;
            z-index: 200;
        }

        #reticle.active {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        /* In-Game UI */
        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }

        #mission-text {
            position: absolute;
            bottom: 50px;
            width: 100%;
            text-align: center;
            font-size: 1rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
        }

        #chapter-title {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            letter-spacing: 5px;
            opacity: 0.5;
        }

        #return-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: auto;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 5px 10px;
            font-size: 0.7rem;
            display: none;
            background: rgba(0, 0, 0, 0.5);
        }

        #return-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: white;
        }
    </style>
</head>

<body>

    <!-- Narrative Intro -->
    <div id="narrative-overlay">
        <div id="intro-lines"></div>
        <button id="start-btn">BEGIN ARCHITECTURE</button>
    </div>

    <!-- Gameplay UI -->
    <div id="game-ui">
        <div id="chapter-title">CHAPTER I: THE SEPARATION</div>
        <div id="mission-text"></div>
        <div id="return-btn">RETURN TO MUSEUM</div>
    </div>

    <div id="reticle"></div>
    <div id="canvas-container"></div>

    <!-- Three.js Import -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        // --- Narrative Data ---
        const INTRO_LINES = [
            "The world is broken.",
            "Words have drifted from their objects.",
            "Meaning has dissolved into noise.",
            "You are the Architect.",
            "You must rebuild the bridges.",
            "Restore the connection."
        ];

        class Game {
            constructor() {
                this.container = document.getElementById('canvas-container');
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x050505);
                this.scene.fog = new THREE.FogExp2(0x050505, 0.02);

                this.initCamera();
                this.initRenderer();
                this.initPostProcessing();
                this.initLights();
                this.initControls();
                this.initInput();

                this.levels = {};
                this.currentLevelName = '';
                this.activeObjects = [];
                this.level1Completed = false; // Progressive disclosure flag

                window.addEventListener('resize', () => this.onWindowResize());

                this.setupLevels();
                this.startIntro();
            }

            // --- Initialization ---
            initCamera() {
                this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 2, 8);
            }

            initRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: false });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.container.appendChild(this.renderer.domElement);
            }

            initPostProcessing() {
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));

                // Very subtle bloom for visual polish without blinding
                this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                this.bloomPass.strength = 0.3;
                this.bloomPass.radius = 0.2;
                this.bloomPass.threshold = 0.8;
                this.composer.addPass(this.bloomPass);

                this.composer.addPass(new OutputPass());
            }

            initLights() {
                this.ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                this.scene.add(this.ambientLight);

                this.dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
                this.dirLight.position.set(5, 10, 7);
                this.dirLight.castShadow = true;
                this.scene.add(this.dirLight);
            }

            initControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.enablePan = false;
                this.controls.maxPolarAngle = Math.PI / 2 + 0.1; // allow slightly below horizon
                this.controls.minDistance = 3;
                this.controls.maxDistance = 15;
                this.controls.enabled = false; // Disabled during intro
            }

            initInput() {
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.reticle = document.getElementById('reticle');

                window.addEventListener('mousemove', (e) => {
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    this.reticle.style.left = e.clientX + 'px';
                    this.reticle.style.top = e.clientY + 'px';
                    this.checkHover();
                });

                window.addEventListener('mousedown', (e) => { this.onMouseDown(e); });
                window.addEventListener('mouseup', () => { this.onMouseUp(); });
                window.addEventListener('click', (e) => { this.onClick(e); });

                // Return button logic
                document.getElementById('return-btn').addEventListener('click', () => {
                    this.loadLevel('hub');
                });
            }

            // --- Narrative System ---
            async startIntro() {
                const container = document.getElementById('intro-lines');
                const btn = document.getElementById('start-btn');

                // Play narrative lines one by one
                for (let line of INTRO_LINES) {
                    container.innerHTML = `<div class="narrative-text active">${line}</div>`;
                    await new Promise(r => setTimeout(r, 2500)); // Read time
                    container.innerHTML = ''; // Clear
                    await new Promise(r => setTimeout(r, 500)); // Pause
                }

                // Show Start Button
                btn.style.display = 'block';
                setTimeout(() => btn.style.opacity = 1, 100);

                btn.addEventListener('click', () => {
                    document.getElementById('narrative-overlay').style.opacity = 0;
                    setTimeout(() => {
                        document.getElementById('narrative-overlay').style.display = 'none';
                        this.container.style.opacity = 1;
                        document.getElementById('game-ui').style.display = 'block';
                        this.animate();
                        // START DIRECTLY IN LEVEL 1
                        this.loadLevel('level1');
                    }, 1000);
                });
            }

            // --- Level Management ---
            setupLevels() {
                // LEVEL 1: THE TREE (CONCRETE)
                this.addLevel('level1', (group) => {
                    this.scene.background = new THREE.Color(0x222222);
                    this.controls.enabled = true;
                    document.getElementById('chapter-title').innerText = "CHAPTER I: THE SEPARATION";
                    document.getElementById('mission-text').innerText = "DRAG TO ALIGN THE WORD WITH THE OBJECT";
                    document.getElementById('return-btn').style.display = 'none'; // Can't leave yet

                    // 1. The Broken Ring (Geometry)
                    const radius = 2.5;
                    const height = 0.5;
                    const segments = 64;

                    // Left Half (Word) - Gold/Paper
                    const geo1 = new THREE.CylinderGeometry(radius, radius, height, segments, 1, false, Math.PI, Math.PI);
                    const mat1 = new THREE.MeshStandardMaterial({
                        color: 0xaa8866, roughness: 0.8, flatShading: false
                    });
                    const half1 = new THREE.Group();
                    const mesh1 = new THREE.Mesh(geo1, mat1);
                    mesh1.rotation.x = Math.PI / 2;
                    half1.add(mesh1);

                    // Text "TREE"
                    const canvas = document.createElement('canvas');
                    canvas.width = 512; canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = "white";
                    ctx.font = "bold 80px Courier New";
                    ctx.textAlign = "center";
                    ctx.fillText("TREE", 256, 150);
                    const tex = new THREE.CanvasTexture(canvas);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
                    sprite.scale.set(4, 2, 1);
                    sprite.position.set(0, 1.5, 0.2);
                    half1.add(sprite);

                    // Right Half (Object) - Green/Organic
                    const geo2 = new THREE.CylinderGeometry(radius, radius, height, segments, 1, false, 0, Math.PI);
                    const mat2 = new THREE.MeshStandardMaterial({
                        color: 0x225522, roughness: 0.6
                    });
                    const half2 = new THREE.Group();
                    const mesh2 = new THREE.Mesh(geo2, mat2);
                    mesh2.rotation.x = Math.PI / 2;
                    half2.add(mesh2);

                    // Low Poly Tree Model inside Half 2
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.2, 0.4, 1.5, 6),
                        new THREE.MeshStandardMaterial({ color: 0x553311 })
                    );
                    trunk.rotation.x = Math.PI / 2;
                    trunk.position.y = -0.5;

                    const leaves = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(1.2),
                        new THREE.MeshStandardMaterial({ color: 0x228822, flatShading: true })
                    );
                    leaves.position.y = -1.5; // Visual offset inside hoop
                    leaves.rotation.x = Math.PI / 2;

                    half2.add(trunk);
                    half2.add(leaves);

                    // Positioning
                    half1.position.x = -0.1;
                    half2.position.x = 0.1;

                    // Initial Separation (Misaligned)
                    half1.rotation.z = Math.PI / 2; // Crooked

                    group.add(half1);
                    group.add(half2);

                    // GHOST HINT
                    const ghost = new THREE.Mesh(geo1, new THREE.MeshBasicMaterial({
                        color: 0xffaa00, wireframe: true, transparent: true, opacity: 0.1
                    }));
                    ghost.rotation.x = Math.PI / 2;
                    ghost.position.set(-0.1, 0, 0);
                    group.add(ghost);

                    // Logic
                    let won = false;
                    let isDragging = false;

                    group.userData.onMouseDown = () => { isDragging = true; };
                    group.userData.onMouseUp = () => { isDragging = false; };
                    group.userData.onMouseMove = (e) => {
                        if (isDragging && !won) {
                            half1.rotation.z += e.movementX * 0.005;
                            checkWin();
                        }
                    };

                    const checkWin = () => {
                        // Normalize angle
                        let r = half1.rotation.z % (Math.PI * 2);
                        if (r > Math.PI) r -= Math.PI * 2;
                        if (r < -Math.PI) r += Math.PI * 2;

                        // Win if angle is close to 0
                        if (Math.abs(r) < 0.1) {
                            won = true;
                            // Snap
                            half1.rotation.z = 0;
                            half1.position.x = 0;
                            half2.position.x = 0;

                            // Effects
                            this.bloomPass.strength = 1.0;
                            ghost.visible = false;
                            document.getElementById('mission-text').innerText = "MEANING RESTORED.";
                            document.getElementById('mission-text').style.color = "#FFD700";

                            // Fade out bloom slowly
                            let fade = setInterval(() => {
                                this.bloomPass.strength *= 0.95;
                                if (this.bloomPass.strength < 0.3) clearInterval(fade);
                            }, 50);

                            // Show next step after delay
                            setTimeout(() => {
                                this.level1Completed = true; // Unlock hub
                                this.createNextButton(group, "ENTER THE MUSEUM");
                            }, 2000);
                        }
                    };
                });

                // HUB (Museum)
                this.addLevel('hub', (group) => {
                    this.scene.background = new THREE.Color(0x111111);
                    document.getElementById('chapter-title').innerText = "THE MUSEUM OF MEANING";
                    document.getElementById('mission-text').innerText = "EXPLORE THE CONCEPTS";
                    document.getElementById('return-btn').style.display = 'none';

                    // Plinth Factory
                    const createExhibit = (x, z, color, id, name) => {
                        const base = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 4, 1),
                            new THREE.MeshStandardMaterial({ color: 0x333333 })
                        );
                        base.position.set(x, -1, z);
                        group.add(base);

                        // Floating Artifact
                        const gem = new THREE.Mesh(
                            new THREE.OctahedronGeometry(0.4),
                            new THREE.MeshStandardMaterial({
                                color: color, emissive: color, emissiveIntensity: 1,
                                transparent: true, opacity: 0.8
                            })
                        );
                        gem.position.set(x, 1.5, z);

                        // Animation metadata
                        gem.userData = { id: id, name: name, baseY: 1.5, phase: Math.random() * 10 };
                        this.activeObjects.push(gem);
                        group.add(gem);

                        // Label (3D Text simplified as sprite)
                        const canvas = document.createElement('canvas');
                        canvas.width = 256; canvas.height = 64;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = "rgba(255,255,255,0.5)";
                        ctx.font = "20px Courier New";
                        ctx.textAlign = "center";
                        ctx.fillText(name, 128, 40);
                        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
                        sprite.position.set(x, 2.2, z);
                        sprite.scale.set(2, 0.5, 1);
                        group.add(sprite);
                    };

                    this.activeObjects = []; // Reset active list

                    // 1. The Tree (Already done, but revisit)
                    createExhibit(-3, 0, 0xffaa00, 'level1', 'THE TREE');

                    // 2. The Triangle (Peirce)
                    createExhibit(0, 0, 0x00ffff, 'level2', 'THE TRIANGLE');

                    // 3. The Myth (Barthes)
                    createExhibit(3, 0, 0xff4444, 'level3', 'THE MYTH');

                    this.controls.enabled = true;
                });

                // LEVEL 2: PEIRCE (Triangle)
                this.addLevel('level2', (group) => {
                    this.scene.background = new THREE.Color(0x111122);
                    document.getElementById('chapter-title').innerText = "CHAPTER II: THE TRIAD";
                    document.getElementById('mission-text').innerText = "USE ARROW KEYS TO CONNECT THE INTERPRETANT";
                    document.getElementById('return-btn').style.display = 'block';

                    // Setup Triangle Logic (Simplified from previous)
                    const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(0.8), new THREE.MeshStandardMaterial({ color: 0x888888 }));
                    rock.position.set(-3, 0, -2);
                    group.add(rock);

                    const sign = new THREE.Mesh(new THREE.BoxGeometry(1, 1.4, 0.1), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                    sign.position.set(3, 0, -2);
                    group.add(sign);

                    const interpretant = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1, 4), new THREE.MeshStandardMaterial({
                        color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.5
                    }));
                    interpretant.position.set(0, 1, 3);
                    group.add(interpretant);

                    // Beam
                    const beam = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                    beam.geometry.translate(0, 0.5, 0);
                    beam.rotation.x = -Math.PI / 2;
                    group.add(beam);

                    // Logic
                    group.userData.onKeyDown = (e) => {
                        const s = 0.5;
                        if (e.key === 'ArrowLeft') interpretant.position.x -= s;
                        if (e.key === 'ArrowRight') interpretant.position.x += s;
                        if (e.key === 'ArrowUp') interpretant.position.z -= s;
                        if (e.key === 'ArrowDown') interpretant.position.z += s;
                    };

                    group.userData.update = () => {
                        // Beam follows rock -> interpretant
                        beam.position.copy(rock.position);
                        beam.lookAt(interpretant.position);
                        beam.rotateX(Math.PI / 2);
                        beam.scale.set(1, rock.position.distanceTo(interpretant.position), 1);

                        // Win condition
                        if (Math.abs(interpretant.position.x) < 1 && Math.abs(interpretant.position.z + 2) < 1) {
                            interpretant.material.color.setHex(0x00ff00);
                            document.getElementById('mission-text').innerText = "SEMIOSIS ACTIVE";
                            document.getElementById('mission-text').style.color = "#00ff00";
                        }
                    };
                });

                // LEVEL 3: BARTHES (Myth)
                this.addLevel('level3', (group) => {
                    this.scene.background = new THREE.Color(0x332211);
                    document.getElementById('chapter-title').innerText = "CHAPTER III: THE MYTH";
                    document.getElementById('mission-text').innerText = "DRAG MOUSE UP TO MYTHOLOGIZE";
                    document.getElementById('return-btn').style.display = 'block';

                    const soldier = new THREE.Group();
                    const mat = new THREE.MeshStandardMaterial({ color: 0x556644 });
                    soldier.add(new THREE.Mesh(new THREE.BoxGeometry(1, 2, 0.5), mat));
                    soldier.add(new THREE.Mesh(new THREE.SphereGeometry(0.5), mat));
                    soldier.children[1].position.y = 1.2;
                    group.add(soldier);

                    let value = 0;
                    group.userData.onMouseMove = (e) => {
                        // Simple vertical mouse position maps to myth value
                        value = 1 - (e.clientY / window.innerHeight);

                        const gold = new THREE.Color(0xffaa00);
                        const drab = new THREE.Color(0x556644);
                        mat.color.lerpColors(drab, gold, value);
                        mat.emissive.setHex(0xffaa00);
                        mat.emissiveIntensity = value;

                        soldier.rotation.y += 0.02;
                    };
                });
            }

            addLevel(name, fn) { this.levels[name] = fn; }

            loadLevel(name) {
                // Cleanup
                if (this.currentLevelObject) {
                    this.scene.remove(this.currentLevelObject);
                    this.currentLevelObject = null;
                }

                // Init new
                this.currentLevelName = name;
                this.currentLevelObject = new THREE.Group();
                this.scene.add(this.currentLevelObject);

                // Reset Camera
                this.camera.position.set(0, 3, 8);
                this.camera.lookAt(0, 0, 0);

                if (this.levels[name]) this.levels[name](this.currentLevelObject);
            }

            createNextButton(group, text) {
                const canvas = document.createElement('canvas');
                canvas.width = 512; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = "rgba(0,0,0,0.8)";
                ctx.fillRect(0, 0, 512, 128);
                ctx.strokeStyle = "white";
                ctx.lineWidth = 5;
                ctx.strokeRect(10, 10, 492, 108);
                ctx.fillStyle = "white";
                ctx.font = "bold 40px Courier New";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(text, 256, 64);

                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
                sprite.position.set(0, -2, 2);
                sprite.scale.set(4, 1, 1);

                // Raycastable
                sprite.userData = { isButton: true, action: () => this.loadLevel('hub') };
                this.activeObjects.push(sprite);

                group.add(sprite);
            }

            // --- Loop ---
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }

            checkHover() {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.activeObjects);
                if (intersects.length > 0) {
                    this.reticle.classList.add('active');
                    document.body.style.cursor = 'pointer';
                } else {
                    this.reticle.classList.remove('active');
                    document.body.style.cursor = 'none';
                }
            }

            onMouseDown(e) {
                if (this.currentLevelObject && this.currentLevelObject.userData.onMouseDown)
                    this.currentLevelObject.userData.onMouseDown(e);
            }
            onMouseUp(e) {
                if (this.currentLevelObject && this.currentLevelObject.userData.onMouseUp)
                    this.currentLevelObject.userData.onMouseUp(e);
            }
            onClick(e) {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.activeObjects);
                if (intersects.length > 0 && intersects[0].object.userData.isButton) {
                    intersects[0].object.userData.action();
                    return;
                }
                if (intersects.length > 0 && intersects[0].object.userData.id) {
                    this.loadLevel(intersects[0].object.userData.id);
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const dt = 0.016;

                // Intro is handled separately via DOM opacity
                if (this.currentLevelObject) {
                    // Level specific updates
                    if (this.currentLevelObject.userData.update) this.currentLevelObject.userData.update();

                    // Mouse move propagation
                    if (this.currentLevelObject.userData.onMouseMove)
                        this.currentLevelObject.userData.onMouseMove({ movementX: 1 }); // Mock relative? No, need real event.
                    // Actually better to hook window event to pass data but keep simple for now
                }

                // Animate floating gems in Hub
                if (this.currentLevelName === 'hub') {
                    this.activeObjects.forEach(obj => {
                        if (obj.userData.phase) {
                            obj.position.y = obj.userData.baseY + Math.sin(Date.now() * 0.001 + obj.userData.phase) * 0.1;
                            obj.rotation.y += 0.01;
                        }
                    });
                }

                this.controls.update();
                this.composer.render();
            }
        }

        // Pass mouse moves to active level
        const game = new Game();
        window.addEventListener('mousemove', (e) => {
            if (game.currentLevelObject && game.currentLevelObject.userData.onMouseMove)
                game.currentLevelObject.userData.onMouseMove(e);
        });
        window.addEventListener('keydown', (e) => {
            if (game.currentLevelObject && game.currentLevelObject.userData.onKeyDown)
                game.currentLevelObject.userData.onKeyDown(e);
        });

        window.gameInstance = game;
    </script>
</body>

</html>